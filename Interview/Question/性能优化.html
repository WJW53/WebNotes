<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
 <script>

// 性能优化
        前端优化的途径有很多，大致可以分为两类：页面级优化和代码级优化。

        页面级优化有减少HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等等。

        代码级优化有Js种DOM操作优化、Css选择符优化、图片优化以及HTML结构优化等等。

    1.页面级优化
    2.代码级优化


//页面级优化:
    //<----1.减少HTTP请求数  (最重要最有效)----->
        一个完整的请求都需要经过DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个漫长而复杂的过程。
        由于浏览器进行并发请求的请求数都是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，
        会给用户造成网站速度慢这样一个印象，即使可能用户能看到的第一屏的资源都已经请求完了，但是浏览器的进度条一直在加载。

           // 减少HTTP请求数的途径主要有一下几个：

                /（1）从设计实现层面简化页面

                如果我么你的页面和百度搜索的页面一眼简单，那么也就不需要什么优化操作了。因此保持页面简洁、减少资源的使用是最直接的。

                /（2）合理设置HTTP缓存

                缓存的力量是强大的，恰当的设置缓存可以大大减少HTTP请求
                怎样才算是合理的设置？原则很简单：能缓存越多越久越好。
                例如：很少变化的图片资源就可以直接通过HTTP Header中的Expires设置一个很长的过期头；
                变化不频繁而又可能会变的资源可以使用Last-Modified来做请求验证。尽可能的让资源能够在缓存中待的更久。

                /（3）资源合并与压缩

                如果可以的话，尽可能的将外部脚本、样式进行合并，尽可能地合并为一个。另外，CSS、Js、Image都可以用相应的工具
                进行压缩，压缩后往往能节省不少空间。或者使用Webpack等前端工程化工具来进行代码的压缩和去重。

                /（4）CSS Sprites 雪碧图

                雪碧图又叫做精灵图，我们可以把网站中需要用到的一些icon，全部放到一个图片资源中，然后通过改变位置来
                获取需要的图片，这样合并CSS图片，就可以大幅度减少HTTP请求数了。

               / (5). Inline Images
            　　使用 data: URL scheme的方式将图片嵌入到页面或 CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。
                如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在 CSS中的图片则更为理想一些。

               / (6). Lazy Load Images（自己对这一块的内容还是不了解） 懒加载
　　              这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少 HTTP请求数。
                 对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，
                 假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。
                 有啊首页 曾经的做法是在加载的时候把第一屏之后的图片地址缓存在 Textarea标签中，待用户往下滚屏的时候才 “惰性” 加载。

                /（6）瀑布流

                其实懒加载并不能减少HTTP请求数，他只是可以减少页面刚加载的时候的HTTP请求数，总数是不变的。
                对于图片而言，在页面刚加载的时候可能只加载第一屏的图片，随着用户的滚动才会继续加载后面的图片资源，
                这种瀑布流的加载方式就可以有效提高性能。

       // 2.将外部脚本放在底部
            前文有谈到，浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，
            例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。
            如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。解决这一问题的方法有很多，
            在 这里有比较详细的介绍 (这里是译文和 更详细的例子 )，而最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。

       // 3.并发执行inline脚本
            使用 script元素的defer 属性(存在兼容性问题和其他一些问题，例如不能使用 document.write)、使用setTimeout ，此外，
            在HTML5中引入了 Web Workers的机制，恰恰可以解决此类问题。

       // 4.懒加载
            只需要在需要资源的时候才加载资源，不需要的时候就不加载资源。

        // 5. 将 CSS放在 HEAD中
　　          如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，
              用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。

               / Js 与 css 懒加载
                把js放到整个页面的底部， 另一个方法是在script 标签上加一个 defer属性 保证让浏览器把脚本下载出来后，
                然后等到页面渲染完毕再执行。（参考权威指南 js时间线）
                Css文件用link标签加载 是阻塞状态的，我们可以使用loadCss 小工具库来进行异步css文件加载，但是有一个问题是
                ，全部异步加载css ，页面最开始呈现出的只是单纯的html ,不是很好看 所以我们要选定一个关键的css文件，
                 用critical 工具来自动提取压缩关键的css. （百度自行查看使用方法）


       // 8.减少不必要的HTTP跳转

            对于以目录形式访问的HTTP链接，很多人都会忽略链接最后是否带’/’，加入你的服务器对此区别对待的话，那么你也需要注意了，
            这其中很可能隐藏了301跳转，增加了多余请求。

       // 9.避免重复的资源请求

        这种情况主要是由于在模块化开发时，我们的不同模块之间可能有相同的部分，导致资源的重复请求。

二、代码级优化

     //1.DOM

        DOM操作应该是脚本中最耗性能的一类操作
    /（1）HTMLCollection（HTML收集器，返回的是一个数组的内容信息）
        因为是这个集合并不是一个静态的集合，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个 查询从而更新查询结果。
        所谓的“访问集合”包括读取集合的length属性、访问集合中的元素。

    /（2）Reflow&Repaint
        减少页面的重绘和重排。

    //2.慎用with
        with会改变作用域链，有可能导致我们的作用域链变长，导致查询性能下降。

    //3.避免使用eval和Function
        每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作
        —— 通常比简单的函数调用慢 100倍以上。

   // 4.减少作用域链查找
        如果在循环中需要访问非本作用域下的变量的时候，请遍历之前用局部变量缓存的变量，并在遍历结束之后重写这个缓存变量

    //5.数据访问

        js中对直接量和局部变量的访问时最快的，对对象属性以及数组的访问需要更大的开销，当出现下面的情况的时候，建议将数据放入局部变量：

        /（1）对任何对象属性的访问超过1次

        /（2）对任何数组成员的访问次数超过1次

        另外，要尽可能的减少对对象以及数组的深度查找。

    //6.字符串拼接

        字符串的拼接尽可能少的使用“+”，这种方式的效率是十分低下的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接的结果赋
        值给新变量。

        建议使用的是先转化为数组，然后通过数组的join方法来连接成字符串。不过由于数组也有一定的开销，因此就需要权衡一下，当拼接的字符串比
        较少的时候，可以考虑用“+”的方式，比较多的时候就需要考虑用数组的join方法了。


+++++++++++重绘重排++++++++++++++++++++
重绘和重排:

页面有三个树：DOMTree、CSSTree、renderTree。（实际上多于三个），renderTree上有两个规则：repaint和reflow，重绘和重排。

repaint是元素自身的位置和宽高不变，只改变颜色的之类的属性而不会导致后面的元素位置的变化的时候，renderTree发生的动作。

reflow是元素自身的位置或者宽高改变了从而导致的整个页面的大范围移动的时候，renderTree发生的动作。

所以我们在DOM操作的时候，要尽量避免重排。





     </script>
</body>
</html>