[toc]
# 强缓存和协商缓存

https://www.jianshu.com/p/d04c33385eca

1.缓存的好处
减少了不必要的网络请求次数，减轻了服务器的压力，加快了浏览器打开网页的速度；

2.强缓存和协商缓存策略的区别
强缓存：浏览器不会向服务器发送请求，直接根据max-age和Expires首部字段判断是否使用本地缓存；

协商缓存：浏览器会向服务器发送请求，请求携带首部字段If-None-match和If-Modified-Since，和请求资源的ETag和Last-Modified字段比较，根据结果判断是否使用本地缓存；

3.本地缓存分类
memory cache：内存缓存，一般脚本，图片，字体会缓存在内存中；

disk cache：硬盘缓存，一般非脚本文件（如css文件）会缓存在硬盘中；

4.浏览器缓存的详细过程
1.浏览器第一次加载资源文件，会将服务器返回的资源文件和响应首部字段一并缓存下来；

2.浏览器下一次请求该资源文件的时候，先比较当前时间和上一次响应的时间差是否小于Cache-Control字段的max-age值，如果小于则命中强缓存，直接从本地缓存加载文件；否则浏览器会向服务器发送携带If-None-match和If-Modified-Since首部字段的请求（如果浏览器不支持http1.1会用Expires进行判断）；

3.服务器接收到请求后，会比较资源文件的ETag和请求首部字段If-None-match，不一致则表示资源文件有改动，返回新的资源文件和ETag，一致则进入下一步；

4.比较资源文件的Last-Modified和请求首部字段If-Modified-Since，不一致则表示资源文件有改动，返回新的资源文件和Last-Modified，一致则命中协商缓存，返回403 Not Modified，浏览器从本地缓存加载文件；

5.ETag和Last-Modified区别
1.ETag根据资源文件的内容记录了资源文件的每一次改动，Last-Modified记录了资源文件上一次改动的时间，精确度为秒；

2.服务器校验时ETag的优先级高于Last-Modified，但是ETag更加耗费服务器性能；

6.用户行为对于浏览器缓存的影响
点击页面刷新按钮和F5刷新：向服务器发送请求，会走协商缓存；

Ctrl+F5强制刷新：不走强缓存和协商缓存，服务器每次都返回最新的资源文件；

7.浏览器缓存流程图

![]https://upload-images.jianshu.io/upload_images/22837849-5a8a6ca8b55ce930.png?imageMogr2/auto-orient/strip|imageView2/2/w/656/format/webp



# 强制缓存和协商缓存有什么区别

- 这个写的比较好
http://www.cnblogs.com/wonyun/p/5524617.html

https://blog.csdn.net/learning_web/article/details/90757542

1.背景介绍

做前端有两个比较令人头痛的事，一个是命名，另一个就是缓存了。HTTP协议提供了非常强大的缓存机制， 了解这些缓存机制，对提高网站的性能非常有帮助。

2.知识剖析

什么是浏览器缓存

浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。

浏览器是如何判断是否使用缓存的

浏览器缓存的优点有：

1.减少了冗余的数据传输，节省了网费

2.减少了服务器的负担，大大提升了网站的性能

3.加快了客户端加载网页的速度

浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。

1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码;

2.协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。

缓存中header的参数：

强制缓存

Expires：response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。

Cache-Control：当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

cache-control除了该字段外，还有下面几个比较常用的设置值：

-no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。

-no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。

-public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。

-private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。

协商缓存

Last-Modify/If-Modify-Since：浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存

Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。

If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定是否命中协商缓存；

ETag和Last-Modified的作用和用法，他们的区别：

1.Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；

2.在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值；

3.在优先级上，服务器校验优先考虑Etag。

浏览器缓存过程

1.浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；

2.下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求

3.服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；；

4.如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；；

3.常见问题

用户行为对浏览器缓存的影响

4.解决方案

点击刷新按钮或者按F5

浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match,这就意味着服务器会对文件检查新鲜度，返回结果可能是304，也有可能是200.

用户按Ctrl+F5（强制刷新）

浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是200.

地址栏回车

浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。

5.编码实战

6.扩展思考

为什么修真院官网请求文件后面加上?ver=49

客户端会缓存这些css或js文件，因此每次升级了js或css文件后，改变版本号，客户端浏览器就会重新下载新的js或css文件 ，刷性缓存的作用。大家可能有时候发现修改了样式或者js，刷新的时候不变，就是客户端缓存了css或者js文件

7.参考文献

参考一：http强制缓存和协议缓存http://www.cnblogs.com/wonyun/p/5524617.html

8.更多讨论

其他的常见浏览器状态

400 Bad Request

1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。

2、请求参数有误。

415 Unsupported Media Type

对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。