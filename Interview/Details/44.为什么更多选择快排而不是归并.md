# 为什么平时选择快排更多一点而不是归并呢

最近在看《图解算法》，正好回答这个问题。书中的意思是，虽然同样是O(nlogn)，但是实际上算法的运行时间一般是`O(c*nlogn)`，有个常数。只不过平时考虑运行时间的时候把他省略掉了。这两种排序中，`快排的常量比合并排序小`。

`对于数组这样的线性结构，快排需要的移动次数少`。算法实际使用的时候，不仅要考虑复杂度，常数也得考虑。

另外实际实现中往往会在元素数量足够少的时候改用O(n^2)的算法，因为这时候常数上的优势已经能压倒复杂度了。

快排退化到O(n^2)的概率很小

另外还有一个相对次要点的问题是，`快排空间复杂度是O(logn)，归并是O(n)。`

快排是原地排序，占用空间少，顺便使得访存开销减少。而归并排序不是原地排序

**另**：实际问题中归并排序并不比快排应用少。快排需要递归，就这一点基就可以在许多大数据应用场景把它枪毙了。`而归并排序的scale能力比快排好很多，可以分布式处理`，其实很受欢迎的。

`但改进的归并排序+插入排序算法Timsort却使用广泛`，是 Python/Java/Octave 的内置排序算法；因为实际应用场景中有一些数据段天然有序，那么`timsort针对这些天然有序的字段进行了一系列的优化`

