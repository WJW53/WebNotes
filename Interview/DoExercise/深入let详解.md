# let到底存不存在变量提升

https://www.jianshu.com/p/0f49c88cf169?appinstall=0@


**首先明确一点：提升不是一个技术名词。**

`要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」`

有的地方把创建说成是声明（declare），为了将这个概念与变量声明区别开，我故意不使用声明这个字眼。

有的地方把初始化叫做绑定（binding），但我感觉这个词不如初始化形象。


这就解释了为什么在 let x 之前使用 x 会报错：
```js
let x = 'global';
{
  console.log(x); // Uncaught ReferenceError: x is not defined
  let x = 1;
}
```
原因有两个

1. console.log(x) 中的 x 指的是下面的 x，而不是全局的 x
2. 执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）

看到这里，你应该明白了 let 到底有没有提升：

1. `let 的「创建」过程被提升了，但是初始化没有提升。`
2. var 的「创建」和「初始化」都被提升了。
3. function 的「创建」「初始化」和「赋值」都被提升了。
最后看 const，其实 const 和 let 只有一个区别，那就是 `const 只有「创建」和「初始化」，没有「赋值」过程`。

这四种声明，用下图就可以快速理解：

**`所谓暂时性死区，就是不能在初始化之前，使用变量。`**


## 完了吗？

故事依然没有结束，这周我在知乎上问了一个问题：**如何理解 let x = x 报错之后，再次 let x 依然会报错**？（这个问题是饥人谷的学生问我的）

这个问题说明：**如果 let x 的初始化过程失败了，那么**

1. x 变量就将永远处于 created 状态。
2. 你无法再次对 x 进行初始化（`初始化只有一次机会，而那次机会你失败了`）。
3. 由于 x 无法被初始化，所以 x 永远处在暂时死区（也就是盗梦空间里的 limbo）！

有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。

