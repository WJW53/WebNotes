# Proxy 代理

- 代理: 提供了修改底层实现的方式,所以就必须要求底层实现提供API(接口)

- 由 反射Relect提供的API

**相当于是再次封装Reflect提供的API**

`就是在原来目标对象外面套了一层..不额外占用内存空间,代理不占用额外的内存空间,而且给代理赋值就是给目标对象赋值`

```js
//代理一个目标对象
//target: 目标对象
//handler: 是一个普通对象,其中可以重写底层实现(Reflect里的方法才行)
//返回一个代理对象
const proxy = new Proxy(target, handler);
```

以下说的修改意思是调用set

我是代理我说了算。 如果修改了target，proxy在data层面也同步变化，但是页面在当前这次操作后不会变化，不过会在proxy的下次修改后一起改变之前因target造成的变化。因为proxy本身之前数据已经同步了，但是由于修改的是target所以没有render，当后续再来通过proxy修改的时候，自然会打包所有的变化，重新render。

如果是修改的proxy，则数据和页面都会一起变化，因为我们是通过代理修改的底层变化
