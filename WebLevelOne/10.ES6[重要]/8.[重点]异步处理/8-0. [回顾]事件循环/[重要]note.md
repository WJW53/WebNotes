# [回顾]事件循环

**事件循环：event loop，是指函数在执行栈、宿主线程、事件队列中的循环移动。**

JS运行的环境称之为宿主环境.

> 执行栈: call stack,一个数据结构,用于存放各种函数的执行环境. 每一个函数执行之前,它的相关信息会加入到执行栈.函数调用之前,创建执行环境,然后加入到执行栈;函数调用之后,销毁执行环境.

`JS引擎永远执行的是栈的最顶部.`

异步函数: 某些函数不会立即执行,需要等到某个时机到达后才会执行,这样的函数称之为异步函数
            比如: 事件处理函数、定时器..  **异步函数的执行时机,会被宿主环境控制**


- 浏览器宿主环境中包含5个线程:

1. JS引擎: 负责执行执行栈的最顶部代码
2. GUI线程: 负责渲染页面

ps: JS引擎和GUI线程是互相等待的,一个干事儿,另一个就要等着

3. 事件监听线程: 负责监听各种事件
4. 计时线程: 负责计时
5. 网络线程: 负责网络通信(比如:ajax)

> `当上面的线程**发生了某些事情(比如被点击了)**, 如果该线程发现, 这件事情有 处理程序, 它会将该处理程序加入一个叫做事件队列的内存`.`当JS引擎发现, 执行栈中已经没有了任何内容后, 会将事件队列中的第一个函数加入到执行栈中执行`.

- JS引擎对事件队列的取出执行方式, 以及宿主环境的配合, 称之为事件循环

全局上下文清空后才会从事件队列(先看微队列,微队列没东西了才看宏队列)中取出处理程序/函数 加入到执行栈中执行.

事件队列在不同的宿主环境中有所差异,大部分宿主环境会将事件队列进行细分.

在浏览器中, 事件队列分为两种:

1. 宏任务(队列): macroTask, 计时器结束的回调、事件回调、http回调等等绝大部分异步函数都进入宏队列
2. 微任务(队列): MutationObserver(H5的api), Promise产生的回调进入微队列

`MutationObserber用于监听某个DOM对象的变化`
```js
//监听ul
        const observer = new MutationObserver(function B() {
            //当监听的dom元素发生变化时运行的回调函数
            console.log('ul元素发生了变化');
        });
        
        //监听ul
        observer.observe(ul, {
            attributes: true, //监听属性的变化
            childList: true, //监听子元素的变化
            subtree: true, //监听子树的变化
        })

        //取消监听
        // observer.disconnect();
```


**当执行栈清空时, JS引擎首先会将微任务中的所有任务依次执行结束, 如果没有微任务了,则执行宏任务**
