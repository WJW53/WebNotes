# 生成器(Generator)

- 为了更加方便的书写迭代器、迭代器创建函数

1. 什么是生成器？

**生成器是一个通过构造函数Generator创建的对象,很遗憾我们不能new,它是js内部使用的. 生成器既是一个迭代器又是一个可迭代对象,也能用for-of**

2. 如何创建生成器？

生成器的创建,必须使用生成器函数(Generator Function)

3. 那如何书写一个生成器函数呢？

`生成器函数一定返回一个生成器`

async和生成器函数*只能二选一书写!

```js
//这是一个生成器函数,该函数一定返回一个生成器
function *method(){

}
```

它只是简单地得到一个生成器,里面的代码不会直接运行!

4. 生成器函数内部是如何执行的？

> 生成器函数内部是为了给生成器的每次迭代提供数据的

`每次调用生成器的next()方法,将导致生成器函数运行到下一个yield关键字位置,然后返回迭代器内部返回的对象,后面的代码不运行,连当前一行的赋值运算都不会进行! let info = yield 1;会卡在赋值前一刻!!!`

**yield是一个关键字,该关键字只能在生成器函数内部使用,表示"产生"一个迭代数据**


5. 有哪些需要注意的细节？

> 1). 生成器函数可以有返回值, 它出现在第一次done为true时value的属性中
> 2). 调用生成器的next方法时, 可以传递参数, 传递的参数会交给yield表达式的返回值
> 3). 第一次调用next方法时, 传参是没有任何意义的 ?? 因为没有yield,有点不理解
> 4). 在生成器函数内部, 可以调用其他生成器函数, 但是要注意加上 * 


6. 生成器的其他API

- return方法: 调用该方法(可以传参数),可以提前结束生成器函数, 从而提前让整个迭代过程结束
但是可以一直return(参数),这个我发现仍然有效,它只是使next()失效罢了

- throw方法: 调用该方法,可以在生成器中产生一个错误,在上一次yield之后立马报错
