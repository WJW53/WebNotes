<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>

<body>
	<div></div>
	<div></div>
	<div></div>
	<script type="text/javascript">
		// console.log("abc");
		// var c = document.querySelector("div");
		// console.log(c);
		// // c.class = "duyi";
		// c.className = "duyi";


		//
		// console.log(typeof NaN == 'number',typeof Object);

		// function a(xx){
		// 	this.x = xx;
		// 	console.log(this);
		// 	return this;
		// }
		// var x = a(5);
		// console.log(x);//x == window
		// var y = a(6);//最终window.x == 6
		// console.log(y);//y == window
		// console.log(x.x);//window.x.x  -> Number(6).x  -> undefined
		// console.log(Number(5).x);
		// console.log(y.x);//window.y.x --> window.x --> 6


		// var bar = 1;
		// function foo(bar){
		// 	bar = 2;
		// 	console.log(bar);
		// }
		// foo(bar);
		// console.log(bar);
		// console.log('\n');

		// (function(x){
		// 	return (function(y){
		// 		console.log(x);
		// 	}(2));
		// }(1));

		
		//实测arguments实际就是和参数完全绑定在一起了,非严格模式下哈
		function myFunction(parameter1, parameter2) {
			console.log(arguments[0], arguments[1]) // argument1 {a: 1, b: Array(3)}
			// parameter2.b = [1, 3];
			arguments[1].b = [1, 3];
			arguments[0] = "gaibianle";
			console.log(parameter1,arguments[0]);
			console.log(arguments[1]);
			// setTimeout(() => {
				// arguments[1].b = [1, 3, 5];
				// arguments[1] = "ccc";
				// arguments[1] = {new: "new"};
				parameter2 = {pnew:"pnew"};
				console.log(parameter2,arguments[1]);
			// }, 1000);

		};
		var c = {
			a: 1,
			b: [1, 2, 3]
		};
		var a = "argument1";//传给函数的参数,实际上开辟了新的地址空间
		myFunction(a, c);//注意对于引用值,控制台打印的往往是最终的值
		console.log(a, c);//argument1 {a: 1, b: Array(2)}
	</script>
</body>

</html>