# 作用域、作用域链

## 作用域

> 执行(运行)期上下文:
当函数执行时(**准确说是执行前一刻,预编译的时候**)，会创建一个称为执行期上下文的内部对象。
一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的,
所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁。

> [[scope]]:
每个JavaScript函数都是一个对象,对象中有些属性我们可以访问.
但有些不可以,这些属性仅供JavaScript引擎存取,[[scope]]就是其中一个.

- [[scope]]指的就是我们所说的作用域(链),其中**存储了运行期上下文的集合**.

- 作用域链：[[scope]]中所存储的执行期上下文对象的集合,这个集合呈链式链接,这种链式链接叫做作用域链.

> 查找变量: 从该函数的作用域链的顶端(即从第0号位置开始)依次向下查找.


```js

// function test() {}
//[[scope]],是一个隐式的属性,我们没法使用 
        // test.[[scope]]

        function a() {
            function b () {
                var bb = 234;
                // 用这个来检查,是否 b访问到a的AO和a本身的AO是不是同一个AO
                aa=0;
            }
            var aa = 123;
            b();
            // 用这个来检查,是否 b访问到a的AO和a本身的AO是不是同一个AO
            console.log(aa);//0
            //结果证明: 都是同一个玩意儿
        }
        var global = 100;
        a();
        // 步骤：

// 在a刚定义的时候: a.[[scope]] --> 第0号位置指向 : GO{...}
//ps: 刚定义的时候,是看你出生的大环境是什么
//比如这个a刚出生就是在全局的作用域里,它的指向的GO是全局给它的

//当a被执行时: a.[[scope]] -->  第0号位置指向 : AO{}
                        //     第1号位置指向 : GO{}  


//当b刚被定义的时候,b拿到的是a的劳动成果 AO1 GO1
//当b执行的时候,b再将自己产生的AO2放到作用域链的顶端(第0号位置)
//b执行完后,抹掉它和链顶端的联系,注意只是链顶端,因为如果再调用b的话,直接再把线连着就行
//但是当a执行完后,b就直接被抹杀了,永远就没了。而a只是抹杀了自己和AO的联系,但还剩个GO
//看看是否之后还会执行a,若一直没执行a的话,就一直等到最后程序结束,GO就也被抹杀了.
//若再执行了a,就会重连AO,然后新生成一个b. 剩下的就是重复以上步骤
//真正看的是doing时候的变量


```
