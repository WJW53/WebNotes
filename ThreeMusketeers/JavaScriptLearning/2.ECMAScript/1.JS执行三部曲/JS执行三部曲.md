# JS执行三部曲

## 一. 语法分析过程 -- 通篇扫描一遍低级错误


## 二. 预编译

### 下述有两个小现象(粗浅的解释,解决不重名、简单的小问题可以)：

1. 函数声明整体提升
- 系统总是会把函数的声明提升到逻辑最前面,所以代码写哪儿都可以,不影响运行

2. 变量 **声明提升**
- document.writln(a);
  var a = "123";
  结果会显示为undefined,因为只有声明提升了,赋值没提升

### 铺垫知识点

```  全局对象是window,window就是全局的域,像个仓库一样  ```

1. imply global 暗示全局变量:即**任何变量**,如果变量未经声明就赋值,此变量就为全局对象所有
eg: a = 123; ===> window.a = 123;
eg: var a = b = 123;

2. 一切声明的全局变量,全是window的属性
eg:var a = 123; ===> window.a = 123;


### 函数内预编译四部曲

```预编译发生在函数执行的前一刻```

1. 创建AO对象(Activation Object,活动对象),执行期上下文
- 因函数而产生的存储空间库
2. 找形参和变量声明(**if里的一言难尽,Chrome允许你将声明提升其值值为undefined,但是能不能走完它的真实语句要看到时候的if条件是不是真. 但是其他浏览器好像规则又有些不一样了**),将变量和形参名作为AO属性名,值为undefined
3. 将实参值(传进来的真实的参数)和形参值统一
4. 在函数体里面找函数声明(字面量形式,不能是表达式),其值赋予函数体
- ?????????
- 反正实际上应该是把,找到所有函数声明,然后把那整个函数声明作为属性值,传给AO里的对应的属性名

- ps:
```
console.log(b);
var b = function(){}
```

打印的结果是undefined

因为这个东西(函数字面量)不走步骤4,走的是步骤2,算变量声明里


### 全局的预编译

``` GO === window ```

> 与函数内的预编译基本一致,只有以下两点不同:

1. 生成了一个GO对象(Global Object)
2. 少一个环节,无上述第三步"将实参值和形参值统一",因为全局没有参数


### 注意：一定是先生成GO,再生成AO.嵌套关系里,优先使用最深层次的


## 三. 解释执行

一行一行地执行代码(忽略视觉代码效果,要看真正的顺序)

